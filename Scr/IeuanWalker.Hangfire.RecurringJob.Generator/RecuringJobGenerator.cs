using System.Collections.Immutable;
using System.Text;
using Hangfire.States;
using IeuanWalker.Hangfire.RecurringJob.Generator.Helpers;
using IeuanWalker.Hangfire.RecurringJob.Generator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace IeuanWalker.Hangfire.RecurringJob.Generator;

[Generator(LanguageNames.CSharp)]
public class RecuringJobGenerator : IIncrementalGenerator
{
	static string? assemblyName;
	const string fullAttribute = "IeuanWalker.Hangfire.RecurringJob.Attributes.RecurringJobAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValueProvider<ImmutableArray<(List<JobModel> ValidJobs, Dictionary<INamedTypeSymbol, List<string>> InvalidClasses)>> provider = context.SyntaxProvider
						 .ForAttributeWithMetadataName(fullAttribute, Match, Transform)
						 .Where(static r => r.ValidJobs.Any() || r.InvalidClasses.Any())
						 .Collect();

		context.RegisterSourceOutput(provider, Generate!);
	}

	static bool Match(SyntaxNode node, CancellationToken _)
	{
		return true;
	}

	static (List<JobModel> ValidJobs, Dictionary<INamedTypeSymbol, List<string>> InvalidClasses) Transform(GeneratorAttributeSyntaxContext context, CancellationToken _)
	{
		INamedTypeSymbol? markerAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName(fullAttribute);
		if(markerAttribute is null)
		{
			return (new List<JobModel>(), new Dictionary<INamedTypeSymbol, List<string>>(SymbolEqualityComparer.Default));
		}

		List<JobModel> validJobs = [];
		Dictionary<INamedTypeSymbol, List<string>> invalidClasses = new(SymbolEqualityComparer.Default);

		foreach(ImmutableArray<TypedConstant> constructorArguments in context.Attributes
			.Where(a => a?.AttributeClass is not null && a.AttributeClass.Equals(markerAttribute, SymbolEqualityComparer.Default))
			.Select(x => x.ConstructorArguments))
		{
			assemblyName = context.SemanticModel.Compilation.AssemblyName;
			string jobId = context.TargetSymbol.Name;
			string cron = "0 0 * * *";
			string queue = EnqueuedState.DefaultQueue;
			string timeZone = "UTC";

			switch(constructorArguments.Length)
			{
				case 1:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					break;
				case 2:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					queue = constructorArguments[1].Value?.ToString() ?? queue;
					break;
				case 4:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					timeZone = constructorArguments[1].Value?.ToString() ?? timeZone;
					queue = constructorArguments[2].Value?.ToString() ?? queue;
					jobId = constructorArguments[3].Value?.ToString() ?? jobId;
					break;
			}

			if(context.TargetSymbol is INamedTypeSymbol classSymbol)
			{
				List<string> errors = [];

				if(!classSymbol.GetMembers().OfType<IMethodSymbol>().Any(m => m.Name == "Execute" && m.Parameters.Length == 0))
				{
					errors.Add("RJG001: Missing Execute Method");
				}

				if(!TimeZoneInfo.GetSystemTimeZones().Any(tz => tz.Id == timeZone))
				{
					errors.Add($"RJG002: Invalid TimeZone - {timeZone}");
				}

				if(errors.Any())
				{
					invalidClasses[classSymbol] = errors;
				}
				else
				{
					validJobs.Add(new JobModel(context.TargetSymbol.ToString(), jobId, cron, queue, timeZone));
				}
			}
		}

		return (validJobs, invalidClasses);
	}

	static void Generate(SourceProductionContext context, ImmutableArray<(List<JobModel> ValidJobs, Dictionary<INamedTypeSymbol, List<string>> InvalidClasses)> jobs)
	{
		foreach(KeyValuePair<INamedTypeSymbol, List<string>> invalidClassEntry in jobs.SelectMany(x => x.InvalidClasses))
		{
			INamedTypeSymbol invalidClass = invalidClassEntry.Key;

			foreach(string error in invalidClassEntry.Value)
			{
				string diagnosticId = string.Empty;
				string title = string.Empty;
				string messageFormat = string.Empty;

				if(error.StartsWith("RJG001"))
				{
					diagnosticId = "RJG001";
					title = "Missing Execute Method";
					messageFormat = "The class '{0}' must implement a parameterless method named 'Execute'.";
				}
				else if(error.StartsWith("RJG002"))
				{
					diagnosticId = "RJG002";
					title = "Invalid TimeZone";
					messageFormat = "The TimeZone (" + error.Split('-').LastOrDefault()?.Trim() + ") specified for the class '{0}' is invalid.";
				}

				context.ReportDiagnostic(Diagnostic.Create(
					new DiagnosticDescriptor(
						id: diagnosticId,
						title: title,
						messageFormat: messageFormat,
						category: "RecurringJobGenerator",
						DiagnosticSeverity.Error,
						isEnabledByDefault: true),
					invalidClass.Locations.FirstOrDefault(),
					invalidClass.Name));
			}
		}


		List<JobModel> jobsToAdd = jobs.SelectMany(x => x.ValidJobs).ToList();

		if(!jobsToAdd.Any())
		{
			return;
		}

		StringBuilder sb = new();

		sb.Append(@"// <auto-generated/>
using Hangfire;
using Microsoft.AspNetCore.Builder;

namespace ").Append(assemblyName).Append(@"
{
	public static class RecurringJobRegistrationExtensions
	{
		public static IApplicationBuilder AddRecurringJobsFrom").Append(assemblyName?.Sanitize(string.Empty) ?? "Assembly").Append(@"(this IApplicationBuilder app)
		{
");
		foreach(JobModel job in jobsToAdd.OrderBy(r => r.FullClassName))
		{
			sb
				.Append("\t\t\tRecurringJob.AddOrUpdate<").Append(job.FullClassName).Append(">(")
				.Append(SymbolDisplay.FormatLiteral(job.JobId, true)).Append(", ")
				.Append(SymbolDisplay.FormatLiteral(job.Queue, true)).Append(", x => x.Execute(), ")
				.Append(SymbolDisplay.FormatLiteral(job.Cron, true)).Append(", new RecurringJobOptions").Append("\r\n")
				.Append("\t\t\t{\r\n")
				.Append("\t\t\t\tTimeZone = TimeZoneInfo.FindSystemTimeZoneById(").Append(SymbolDisplay.FormatLiteral(job.TimeZone, true)).Append(")\r\n")
				.Append("\t\t\t});\r\n");
		}
		sb.Append(@"  
			return app;
		}
	}
}");

		context.AddSource("RecurringJobRegistrationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	static bool IsValidTimeZone(string timeZone)
	{
		return TimeZoneInfo.GetSystemTimeZones().Any(tz => tz.Id == timeZone);
	}
}