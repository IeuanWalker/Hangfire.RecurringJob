using System.Collections.Immutable;
using System.Text;
using Hangfire.States;
using IeuanWalker.Hangfire.RecurringJob.Generator.Helpers;
using IeuanWalker.Hangfire.RecurringJob.Generator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace IeuanWalker.Hangfire.RecurringJob.Generator;

[Generator(LanguageNames.CSharp)]
public class RecuringJobGenerator : IIncrementalGenerator
{
	static string? assemblyName;
	const string fullAttribute = "IeuanWalker.Hangfire.RecurringJob.Attributes.RecurringJobAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValueProvider<ImmutableArray<(List<JobModel> ValidJobs, List<INamedTypeSymbol> InvalidClasses)>> provider = context.SyntaxProvider
						 .ForAttributeWithMetadataName(fullAttribute, Match, Transform)
						 .Where(static r => r.ValidJobs.Any() || r.InvalidClasses.Any())
						 .Collect();

		context.RegisterSourceOutput(provider, Generate!);
	}

	static bool Match(SyntaxNode node, CancellationToken _)
	{
		return true;
	}

	static (List<JobModel> ValidJobs, List<INamedTypeSymbol> InvalidClasses) Transform(GeneratorAttributeSyntaxContext context, CancellationToken _)
	{
		INamedTypeSymbol? markerAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName(fullAttribute);
		if(markerAttribute is null)
		{
			return (new List<JobModel>(), new List<INamedTypeSymbol>());
		}

		List<JobModel> validJobs = [];
		List<INamedTypeSymbol> invalidClasses = [];

		foreach(ImmutableArray<TypedConstant> constructorArguments in context.Attributes
			.Where(a => a?.AttributeClass is not null && a.AttributeClass.Equals(markerAttribute, SymbolEqualityComparer.Default))
			.Select(x => x.ConstructorArguments))
		{
			assemblyName = context.SemanticModel.Compilation.AssemblyName;
			string jobId = context.TargetSymbol.Name;
			string cron = "0 0 * * *";
			string queue = EnqueuedState.DefaultQueue;
			string timeZone = "UTC";

			switch(constructorArguments.Length)
			{
				case 1:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					break;
				case 2:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					queue = constructorArguments[1].Value?.ToString() ?? queue;
					break;
				case 4:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					timeZone = constructorArguments[1].Value?.ToString() ?? timeZone;
					queue = constructorArguments[2].Value?.ToString() ?? queue;
					jobId = constructorArguments[3].Value?.ToString() ?? jobId;
					break;
			}

			if(context.TargetSymbol is INamedTypeSymbol classSymbol)
			{
				bool hasExecuteMethod = classSymbol.GetMembers()
					.OfType<IMethodSymbol>()
					.Any(m => m.Name == "Execute" && m.Parameters.Length == 0);

				if(!hasExecuteMethod)
				{
					invalidClasses.Add(classSymbol);
					continue;
				}

				// Validate the timeZone
				if(!IsValidTimeZone(timeZone))
				{
					invalidClasses.Add(classSymbol);
					continue;
				}

				validJobs.Add(new JobModel(context.TargetSymbol.ToString(), jobId, cron, queue, timeZone));
			}
		}

		return (validJobs, invalidClasses);
	}

	static void Generate(SourceProductionContext context, ImmutableArray<(List<JobModel> ValidJobs, List<INamedTypeSymbol> InvalidClasses)> jobs)
	{
		foreach(INamedTypeSymbol? invalidClass in jobs.SelectMany(x => x.InvalidClasses))
		{
			// Check if the invalid class is missing the Execute method
			if(invalidClass.GetMembers()
				.OfType<IMethodSymbol>()
				.All(m => m.Name != "Execute" || m.Parameters.Length != 0))
			{
				context.ReportDiagnostic(Diagnostic.Create(
					new DiagnosticDescriptor(
						id: "RJG001",
						title: "Missing Execute Method",
						messageFormat: "The class '{0}' must implement a parameterless method named 'Execute'.",
						category: "RecurringJobGenerator",
						DiagnosticSeverity.Error,
						isEnabledByDefault: true),
					invalidClass.Locations.FirstOrDefault(),
					invalidClass.Name));
			}
			else
			{
				// Report invalid TimeZone error
				context.ReportDiagnostic(Diagnostic.Create(
					new DiagnosticDescriptor(
						id: "RJG002",
						title: "Invalid TimeZone",
						messageFormat: "The TimeZone specified for the class '{0}' is invalid.",
						category: "RecurringJobGenerator",
						DiagnosticSeverity.Error,
						isEnabledByDefault: true),
					invalidClass.Locations.FirstOrDefault(),
					invalidClass.Name));
			}
		}


		List<JobModel> jobsToAdd = jobs.SelectMany(x => x.ValidJobs).ToList();

		if(!jobsToAdd.Any())
		{
			return;
		}

		StringBuilder sb = new();

		sb.Append(@"// <auto-generated/>

using Hangfire;
using Microsoft.AspNetCore.Builder;");

		sb.Append("\r\n\r\nnamespace ").Append(assemblyName).Append(@";

public static class RecurringJobRegistrationExtensions
{
	public static IApplicationBuilder AddRecurringJobsFrom").Append(assemblyName?.Sanitize(string.Empty) ?? "Assembly").Append(@"(this IApplicationBuilder app)
	{
");
		foreach(JobModel job in jobsToAdd.OrderBy(r => r.FullClassName))
		{
			sb
				.Append("\t\tRecurringJob.AddOrUpdate<").Append(job.FullClassName).Append(">(")
				.Append(SymbolDisplay.FormatLiteral(job.JobId, true)).Append(", ")
				.Append(SymbolDisplay.FormatLiteral(job.Queue, true)).Append(", x => x.Execute(), ")
				.Append(SymbolDisplay.FormatLiteral(job.Cron, true)).Append(", new RecurringJobOptions").Append("\r\n")
				.Append("\t\t{\r\n")
				.Append("\t\t\tTimeZone = TimeZoneInfo.FindSystemTimeZoneById(").Append(SymbolDisplay.FormatLiteral(job.TimeZone, true)).Append(")\r\n")
				.Append("\t\t});\r\n");
		}
		sb.Append(@"
		return app;
	}
}");

		context.AddSource("RecurringJobRegistrationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	static bool IsValidTimeZone(string timeZone)
	{
		return TimeZoneInfo.GetSystemTimeZones().Any(tz => tz.Id == timeZone);
	}
}