using System.Collections.Immutable;
using System.Text;
using Hangfire.States;
using IeuanWalker.Hangfire.RecurringJob.Generator.Helpers;
using IeuanWalker.Hangfire.RecurringJob.Generator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace IeuanWalker.Hangfire.RecurringJob.Generator;

[Generator(LanguageNames.CSharp)]
public class RecuringJobGenerator : IIncrementalGenerator
{
	static string? assemblyName;
	const string fullAttribute = "IeuanWalker.Hangfire.RecurringJob.Attributes.RecurringJobAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValueProvider<ImmutableArray<List<JobModel>?>> provider = context.SyntaxProvider
						 .ForAttributeWithMetadataName(fullAttribute, Match, Transform)
						 .Where(static r => r is not null)
						 .Collect();

		context.RegisterSourceOutput(provider, Generate!);
	}

	static bool Match(SyntaxNode node, CancellationToken _)
	{
		return true;
	}

	static List<JobModel>? Transform(GeneratorAttributeSyntaxContext context, CancellationToken _)
	{
		IEnumerable<SyntaxNode> ancestors = context.TargetNode.Ancestors();
		if (ancestors.FirstOrDefault(x => x.IsKind(SyntaxKind.CompilationUnit)) is not CompilationUnitSyntax compilationUnit)
		{
			return null;
		}

		if (compilationUnit.Members.FirstOrDefault(m => m.IsKind(SyntaxKind.NamespaceDeclaration) || m.IsKind(SyntaxKind.FileScopedNamespaceDeclaration)) is not BaseNamespaceDeclarationSyntax)
		{
			return null;
		}

		INamedTypeSymbol? markerAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName(fullAttribute);
		if (markerAttribute is null)
		{
			return null;
		}

		List<JobModel> result = [];
		foreach (ImmutableArray<TypedConstant> constructorArguments in context.Attributes.Where(a => a?.AttributeClass is not null && a.AttributeClass.Equals(markerAttribute, SymbolEqualityComparer.Default)).Select(x => x.ConstructorArguments))
		{
			assemblyName = context.SemanticModel.Compilation.AssemblyName;
			string jobId = context.TargetSymbol.Name;
			string cron = "0 0 * * *";
			string queue = EnqueuedState.DefaultQueue;
			string timeZone = "UTC";

			switch (constructorArguments.Length)
			{
				case 1:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					break;
				case 2:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					queue = constructorArguments[1].Value?.ToString() ?? queue;
					break;
				case 4:
					cron = constructorArguments[0].Value?.ToString() ?? cron;
					timeZone = constructorArguments[1].Value?.ToString() ?? timeZone;
					queue = constructorArguments[2].Value?.ToString() ?? queue;
					jobId = constructorArguments[3].Value?.ToString() ?? jobId;
					break;
			}

			result.Add(new JobModel(context.TargetSymbol.ToString(), jobId, cron, queue, timeZone));
		}

		return result.Count > 0 ? result : null;
	}

	static void Generate(SourceProductionContext context, ImmutableArray<List<JobModel>> jobs)
	{
		List<JobModel> jobsToAdd = jobs.SelectMany(x => x).ToList();

		if (!jobsToAdd.Any())
		{
			return;
		}

		StringBuilder sb = new();

		sb.Append("namespace ").Append(assemblyName).Append(@";

// <auto-generated/>

using Hangfire;
using Microsoft.Extensions.DependencyInjection;

public static class RecurringJobRegistrationExtensions
{
	public static IServiceCollection RegisterRecurringJobsFrom").Append(assemblyName?.Sanitize(string.Empty) ?? "Assembly").Append(@"(this IServiceCollection sc)
	{
");
		foreach (JobModel job in jobsToAdd.OrderBy(r => r.FullClassName))
		{
			sb
				.Append("\t\tRecurringJob.AddOrUpdate<").Append(job.FullClassName).Append(">(\"").Append(job.JobId).Append("\", \"").Append(job.Queue).Append("\", x => x.Execute(), \"").Append(job.Cron).Append("\", new RecurringJobOptions").Append("\r\n")
				.Append("\t\t{\r\n")
				.Append("\t\t\tTimeZone = TimeZoneInfo.FindSystemTimeZoneById(\"").Append(job.TimeZone).Append("\")\r\n")
				.Append("\t\t});\r\n");
		}
		sb.Append(@"
		return sc;
	}
}");

		context.AddSource("RecurringJobRegistrationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}
}